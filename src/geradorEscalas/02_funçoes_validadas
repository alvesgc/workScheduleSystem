import tkinter as tk
from tkinter import filedialog, simpledialog, messagebox
from datetime import datetime
import calendar
from openpyxl.utils import get_column_letter
import re
import locale
from calendar import month_name

def limpar_nome_para_arquivo(nome):
    # Remove caracteres inválidos para nomes de arquivo, mantém letras, números, espaços, underscores e hífens
    return re.sub(r'[\\/:"*?<>|]+', '_', nome).strip()


def selecionar_arquivo_e_pasta():
    root = tk.Tk()
    root.withdraw()
    caminho_modelo = filedialog.askopenfilename(title="Selecione o modelo",
                                                filetypes=[("Excel files", "*.xlsx")])
    if not caminho_modelo:
        messagebox.showerror("Erro", "Nenhum modelo selecionado.")
        exit()
    pasta_destino = filedialog.askdirectory(title="Selecione onde salvar a escala")
    if not pasta_destino:
        messagebox.showerror("Erro", "Nenhuma pasta destino selecionada.")
        exit()
    return caminho_modelo, pasta_destino


def selecionar_setores(setores_disponiveis):
    resultado = []

    def confirmar():
        selecoes = listbox.curselection()
        if not selecoes:
            messagebox.showwarning("Aviso", "Nenhum setor selecionado.")
            return
        for i in selecoes:
            resultado.append(setores_disponiveis[i])
        root.quit()

    root = tk.Tk()
    root.title("Selecione os setores")
    label = tk.Label(root, text="Use Ctrl + clique para selecionar múltiplos setores:")
    label.pack(pady=5)
    listbox = tk.Listbox(root, selectmode=tk.MULTIPLE, width=50, height=len(setores_disponiveis))
    for setor in setores_disponiveis:
        listbox.insert(tk.END, setor)
    listbox.pack(padx=10, pady=5)
    tk.Button(root, text="Confirmar", command=confirmar).pack(pady=10)
    root.mainloop()
    root.destroy()

    return resultado


def escolher_tipo_afastamento(nome_colaborador):
    opcoes = [
        ("F", "FOLGA"),
        ("AF", "AFASTADO INSS"),
        ("AT", "ATESTADO"),
        ("HE", "HORA EXTRA"),
        ("LM", "LICENÇA MATERNIDADE"),
        ("FE", "FÉRIAS")
    ]

    class Dialog(simpledialog.Dialog):
        def body(self, master):
            self.geometry("400x300")  # Aumenta a janela
            self.title("Seleção de Afastamento")

            label_text = f"Selecione o código do afastamento para:\n{nome_colaborador}"
            tk.Label(master, text=label_text, wraplength=380, justify="center", font=("Arial", 10, "bold")).pack(padx=10, pady=10)

            self.listbox = tk.Listbox(master, height=len(opcoes), selectmode=tk.SINGLE, width=40)
            for codigo, desc in opcoes:
                self.listbox.insert(tk.END, f"{codigo} - {desc}")
            self.listbox.pack(padx=10, pady=5)

            return self.listbox

        def apply(self):
            sel = self.listbox.curselection()
            if sel:
                self.result = opcoes[sel[0]][0]
            else:
                self.result = None

    root = tk.Tk()
    root.withdraw()
    dialog = Dialog(root)
    return dialog.result


def aplicar_afastamentos(df_colab, mes, ano, dias_mes):
    """
    Processa os afastamentos dos colaboradores para o mês e ano especificados.

    Parâmetros:
    - df_colab: DataFrame contendo os dados dos colaboradores.
    - mes: mês de referência (int).
    - ano: ano de referência (int).
    - dias_mes: número de dias no mês (int).

    Retorna:
    - dicionário com matrícula como chave e tupla (data início, data fim, motivo) como valor.
    """
    afastados = {}
    for _, row in df_colab.iterrows():
        matricula = str(row["Matrícula"])
        afastamentos = str(row.get("Período de Afastamento", "")).strip()
        if afastamentos:
            try:
                # Espera formato "dd/mm/yyyy a dd/mm/yyyy"
                partes = afastamentos.split(" a ")
                if len(partes) != 2:
                    # Formato inválido, ignora essa linha
                    continue

                inicio = datetime.strptime(partes[0].strip(), "%d/%m/%Y")
                fim = datetime.strptime(partes[1].strip(), "%d/%m/%Y")

                # Verifica se o período de afastamento cobre alguma parte do mês/ano informado
                if inicio <= datetime(ano, mes, dias_mes) and fim >= datetime(ano, mes, 1):
                    # Aqui faz a pergunta para o usuário qual o código do afastamento
                    motivo = escolher_tipo_afastamento(row['Nome'])
                    # Se usuário não informar, usa código padrão "AFAST"
                    if not motivo:
                        motivo = "AFAST"
                    afastados[matricula] = (inicio, fim, motivo)
            except Exception:
                # Ignora erros de parsing e segue com próximo colaborador
                continue
    return afastados


def encontrar_titulos(ws):
    titulos = []
    for row in range(1, ws.max_row + 1):
        valor = str(ws[f"A{row}"].value or "").strip().lower()
        if valor.startswith("título"):
            titulos.append((valor, row))
    return titulos


def alternar_turno(turno_atual, ultimo_dia):
    turno_atual = turno_atual.strip().lower()

    if turno_atual in ["diurno 1", "noturno 1"]:
        if ultimo_dia % 2 == 1:  # ímpar
            return "diurno 2" if "diurno" in turno_atual else "noturno 2"
        else:
            return turno_atual

    elif turno_atual in ["diurno 2", "noturno 2"]:
        if ultimo_dia % 2 == 1:  # ímpar
            return "diurno 1" if "diurno" in turno_atual else "noturno 1"
        else:
            return turno_atual

    return turno_atual

def atualizar_turnos_com_logica_prioritaria(wb, mes, ano):
    print("\n[INÍCIO] Atualização de turnos com lógica da coluna 'Resultado Esperado'\n")

    aba = wb["Cadastro_Colaboradores"]
    colunas = {cell.value: idx for idx, cell in enumerate(aba[1], 1)}

    col_nome = colunas.get("Nome")
    col_tipo_turno = colunas.get("Tipo de Turno")
    col_resultado = colunas.get("Resultado Esperado")

    if not (col_nome and col_tipo_turno and col_resultado):
        print("Erro: Colunas necessárias não encontradas")
        return

    ultimo_dia = calendar.monthrange(ano, mes)[1]
    dia_impar = ultimo_dia % 2 != 0

    for linha in range(2, aba.max_row + 1):
        nome = aba.cell(row=linha, column=col_nome).value or "(sem nome)"
        tipo_turno_atual = aba.cell(row=linha, column=col_tipo_turno).value
        resultado_k = aba.cell(row=linha, column=col_resultado).value

        tipo_turno_atual = str(tipo_turno_atual).strip().lower() if tipo_turno_atual else ""
        resultado_k = str(resultado_k).strip().lower() if resultado_k else ""

        if resultado_k:
            novo_turno = resultado_k
            aba.cell(row=linha, column=col_tipo_turno).value = novo_turno.title()
            print(f"[K PRESENTE] {nome}: usou Resultado Esperado '{resultado_k}' como novo Tipo Turno")
        else:
            novo_turno = tipo_turno_atual
            print(f"[K VAZIO] {nome}: manteve Tipo Turno '{tipo_turno_atual}'")

        # Lógica para novo Resultado Esperado (K)
        if "diurno" in novo_turno or "noturno" in novo_turno:
            base = "diurno" if "diurno" in novo_turno else "noturno"
            if "1" in novo_turno:
                novo_k = f"{base} 2" if dia_impar else f"{base} 1"
            elif "2" in novo_turno:
                if dia_impar:
                    novo_k = f"{base} 1"
                else:
                    novo_k = f"{base} 2"
            else:
                novo_k = ""
        else:
            novo_k = ""

        aba.cell(row=linha, column=col_resultado).value = novo_k.title() if novo_k else ""
        print(f"[RESULTADO] {nome}: Novo Resultado Esperado = {novo_k.title() if novo_k else '(vazio)'}")

    print("\n[FIM] Atualização de turnos concluída\n")



def ocultar_linhas_entre_blocos(ws, titulos):
    """
    Oculta as linhas entre blocos de títulos se a célula da coluna A estiver vazia.
    Inclui prints de depuração para verificar comportamento.
    """

    for titulo, linha in titulos:
        print(f"Título: '{titulo}' na linha {linha}")

    for i in range(len(titulos) - 1):
        linha_inicio = titulos[i][1] + 1
        linha_fim = titulos[i + 1][1]

        for linha in range(linha_inicio, linha_fim):
            valor = ws[f"A{linha}"].value

            if valor is None or str(valor).strip() == "":
                ws.row_dimensions[linha].hidden = True


def ocultar_blocos_vazios(ws, titulos):
    for i in range(len(titulos)):
        linha_titulo = titulos[i][1]
        proxima_linha = titulos[i + 1][1] if i + 1 < len(titulos) else ws.max_row + 1

        linhas_entre = range(linha_titulo, proxima_linha)  # inclui o título

        # Verifica se todas as células da coluna A do bloco estão vazias ou só tem título
        bloco_vazio = True
        for linha in linhas_entre:
            valor = ws[f"A{linha}"].value
            # Considera vazio se None ou string vazia ou só espaços
            if valor is not None and str(valor).strip() != "":
                # Se estiver na linha do título, ok continuar
                if linha == linha_titulo:
                    continue
                else:
                    # Encontrou dado no bloco, não está vazio
                    bloco_vazio = False
                    break

        if bloco_vazio:
            # Oculta o bloco inteiro, inclusive o título
            for linha in linhas_entre:
                ws.row_dimensions[linha].hidden = True
        else:
            # Garante que o bloco fique visível (opcional)
            for linha in linhas_entre:
                ws.row_dimensions[linha].hidden = False



def limpar_cadastro_colaboradores(wb, setores):
    ws = wb["Cadastro_Colaboradores"]
    headers = [cell.value for cell in ws[1]]
    setores_lower = [s.lower().strip() for s in setores]
    nova_lista = []
    for row in ws.iter_rows(min_row=2, values_only=True):
        if str(row[headers.index("Setor")]).strip().lower() in setores_lower:
            nova_lista.append(row)
    ws.delete_rows(2, ws.max_row)
    for i, linha in enumerate(nova_lista, start=2):
        for j, valor in enumerate(linha, start=1):
            ws.cell(row=i, column=j, value=valor)


def ocultar_ate_fim(ws):
    fim_linha = None
    ultima_visivel = 0

    # Encontra a linha com "FIM"
    for row in range(1, ws.max_row + 1):
        valor = ws[f"A{row}"].value
        if valor and str(valor).strip().upper() == "FIM":
            fim_linha = row
            break

    # Se encontrou "FIM", procede
    if fim_linha:
        # Encontra a última linha visível com conteúdo nas colunas A a E
        for linha in range(1, fim_linha):
            if any(ws[f"{col}{linha}"].value for col in "ABCDE") and not ws.row_dimensions[linha].hidden:
                ultima_visivel = linha

        # Se a última visível for só título (sem dados abaixo dela), oculte também
        # Verifica se essa linha tem dados só na coluna A (título) e está fora de bloco
        if (ws[f"B{ultima_visivel}"].value is None and
            ws[f"C{ultima_visivel}"].value is None and
            ws[f"D{ultima_visivel}"].value is None and
            ws[f"E{ultima_visivel}"].value is None):

            ws.row_dimensions[ultima_visivel].hidden = True

        # Oculta todas as linhas entre a nova última visível e a linha FIM (exclui FIM)
        for linha in range(ultima_visivel + 1, fim_linha):
            ws.row_dimensions[linha].hidden = True



def carregar_historico(ws_hist):
    historico_turnos = {}

    for row in ws_hist.iter_rows(min_row=2, values_only=True):
        matricula = str(row[0]) if row[0] is not None else None
        if not matricula:
            continue
        try:
            ultimo_dia = int(row[4]) if row[4] is not None else 0
        except ValueError:
            ultimo_dia = 0

        historico_turnos[matricula] = {
            "nome": row[1],
            "setor": row[2],
            "turno": row[3],
            "ultimo_dia": ultimo_dia
        }

    return historico_turnos


def atualizar_historico(ws, novos):
    if ws.max_row > 1:
        ws.delete_rows(2, ws.max_row - 1)
    for i, item in enumerate(novos, start=2):
        ws[f"A{i}"] = item.get("Nome", "")
        ws[f"B{i}"] = item.get("Matrícula", "")
        ws[f"C{i}"] = item.get("Setor", "")
        ws[f"D{i}"] = item.get("Turno", "")
        ws[f"E{i}"] = item.get("Último Dia Trabalhado", "")



# def preencher_escala(ws, linha_inicio, colaboradores, dias_mes, dias_semana, setor_nome, historico_turnos, novos_turnos, afastados, mes, ano):
#     print(f"Preenchendo setor {setor_nome} na linha {linha_inicio} com {len(colaboradores)} colaboradores")
#
#     ws[f"A{linha_inicio}"] = setor_nome  # Marca o título do setor
#
#     for i, colab in enumerate(colaboradores):
#         linha = linha_inicio + 1 + i
#
#         nome = colab["Nome"]
#         matricula = str(colab["Matrícula"]).strip()
#
#         escala = str(colab["Escala"]).strip().lower()
#         turno_k = str(colab.get('Resultado Esperado', '') or '').strip().lower()
#         if turno_k == "nan":
#             turno_k = ""
#         turno_f = str(colab.get('Tipo de Turno', '')).strip().lower()
#         turno = turno_k if turno_k else turno_f
#
#         # Preenche dados extras
#         ws[f"A{linha}"] = nome
#         ws[f"B{linha}"] = colab.get("Cargo", "")
#         ws[f"C{linha}"] = matricula
#         ws[f"D{linha}"] = colab.get("COREN (opcional)", "")
#         ws[f"E{linha}"] = colab.get("Horário Padrão", "")
#
#         ult_dia_trabalhado = 0
#
#         # Define o estado inicial da escala: True = começa com X, False = começa com F
#         estado_dia = True if turno in ['diurno 1', 'noturno 1'] else False
#
#         # Busca afastamento do colaborador pela matrícula
#         afastamento_info = afastados.get(matricula, None)
#
#         for dia in range(1, dias_mes + 1):
#             col = get_column_letter(6 + dia - 1)
#             celula = f"{col}{linha}"
#             dia_semana = dias_semana[dia - 1]
#
#             if afastamento_info:
#                 inicio, fim, motivo = afastamento_info
#                 data_atual = datetime(ano, mes, dia)
#                 if inicio <= data_atual <= fim:
#                     ws[celula] = motivo
#                     print(f"AFST: {nome} (Mat: {matricula}) - Dia {dia} - {motivo}")
#                     continue
#
#             # ESCALA NORMAL
#             if escala == "12x36":
#                 ws[celula] = "X" if estado_dia else "F"
#                 ult_dia_trabalhado = dia if estado_dia else ult_dia_trabalhado
#                 estado_dia = not estado_dia
#
#
#             elif escala == "diarista":  # Aqui a mudança
#                 if dia_semana in ["SEG", "TER", "QUA", "QUI", "SEX"]:
#                     ws[celula] = "X"
#                     ult_dia_trabalhado = dia
#                 else:
#                     ws[celula] = "F"
#             else:
#                 ws[celula] = ""
#
#         if escala == "diarista" and ult_dia_trabalhado == 0:
#             ult_dia_trabalhado = dias_mes
#
#         novos_turnos[nome] = turno
#         novos_turnos[nome + "_ult_dia"] = ult_dia_trabalhado
#
#     print(f"[FIM] Preenchimento da escala para setor {setor_nome}\n")


from calendar import month_name

def preencher_escala(ws, linha_inicio, colaboradores, dias_mes, dias_semana, setor_nome, historico_turnos, novos_turnos, afastados, mes, ano):
    print(f"Preenchendo setor {setor_nome} na linha {linha_inicio} com {len(colaboradores)} colaboradores")

    # Substituição global de @MES e @ANO em toda a planilha
    meses_pt = {
        1: "JANEIRO", 2: "FEVEREIRO", 3: "MARÇO", 4: "ABRIL",
        5: "MAIO", 6: "JUNHO", 7: "JULHO", 8: "AGOSTO",
        9: "SETEMBRO", 10: "OUTUBRO", 11: "NOVEMBRO", 12: "DEZEMBRO"
    }
    nome_mes = meses_pt.get(mes, "").upper()
    for row in ws.iter_rows():
        for cell in row:
            if cell.value and isinstance(cell.value, str):
                if "@MES" in cell.value or "@ANO" in cell.value:
                    cell.value = cell.value.replace("@MES", nome_mes).replace("@ANO", str(ano))

    ws[f"A{linha_inicio}"] = setor_nome  # Marca o título do setor

    for i, colab in enumerate(colaboradores):
        linha = linha_inicio + 1 + i

        nome = colab["Nome"]
        matricula = str(colab["Matrícula"]).strip()

        escala = str(colab["Escala"]).strip().lower()
        turno_k = str(colab.get('Resultado Esperado', '') or '').strip().lower()
        if turno_k == "nan":
            turno_k = ""
        turno_f = str(colab.get('Tipo de Turno', '')).strip().lower()
        turno = turno_k if turno_k else turno_f

        # Preenche dados extras
        ws[f"A{linha}"] = nome
        ws[f"B{linha}"] = colab.get("Cargo", "")
        ws[f"C{linha}"] = matricula
        ws[f"D{linha}"] = colab.get("COREN (opcional)", "")
        ws[f"E{linha}"] = colab.get("Horário Padrão", "")

        ult_dia_trabalhado = 0
        estado_dia = True if turno in ['diurno 1', 'noturno 1'] else False

        afastamento_info = afastados.get(matricula, None)

        for dia in range(1, dias_mes + 1):
            col = get_column_letter(6 + dia - 1)
            celula = f"{col}{linha}"
            dia_semana = dias_semana[dia - 1]

            if afastamento_info:
                inicio, fim, motivo = afastamento_info
                data_atual = datetime(ano, mes, dia)
                if inicio <= data_atual <= fim:
                    ws[celula] = motivo
                    print(f"AFST: {nome} (Mat: {matricula}) - Dia {dia} - {motivo}")
                    continue

            if escala == "12x36":
                ws[celula] = "X" if estado_dia else "F"
                ult_dia_trabalhado = dia if estado_dia else ult_dia_trabalhado
                estado_dia = not estado_dia

            elif escala == "diarista":
                if dia_semana in ["SEG", "TER", "QUA", "QUI", "SEX"]:
                    ws[celula] = "X"
                    ult_dia_trabalhado = dia
                else:
                    ws[celula] = "F"
            else:
                ws[celula] = ""

        if escala == "diarista" and ult_dia_trabalhado == 0:
            ult_dia_trabalhado = dias_mes

        novos_turnos[nome] = turno
        novos_turnos[nome + "_ult_dia"] = ult_dia_trabalhado

    print(f"[FIM] Preenchimento da escala para setor {setor_nome}\n")










